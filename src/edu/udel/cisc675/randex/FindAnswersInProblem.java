package edu.udel.cisc675.randex;

import java.util.ArrayList;

public class FindAnswersInProblem {

    public final static char[] beginEnumerate =
	"\\begin{enumerate}".toCharArray();
    
    public final static char[] item = "\\item".toCharArray();
    
    public final static char[] endEnumerate =
	"\\end{enumerate}".toCharArray();

    /* The chars array generated by Input module (in) */
    char[] chars;

    /* Start index of each problem, from module FindProblems (in) */
    int[] probStarts;

    /* Stop index of each problem, from module FindProblems (in) */
    int[] probStops;

    /* For each problem i, start index of each answer to the problem
       (out).  This is an array of length number of problems.
       answerStarts[i] is an array whose length is the number of
       answers to the i-th problem.  answerStarts[i][j] is the index
       in chars of the first character of the j-th answer to the i-th
       problem. */
    int[][] answerStarts;

    /* Like answerStarts, except it gives the stop index of each
       answer (out).  That is 1 greater than the index of the last
       character of the answer. */
    int[][] answerStops;

    public FindAnswersInProblem(char[] chars, int[] probStarts, int[] probStops, int[][] answerStarts, int[][] answerStops) {
        this.chars = chars;
        this.probStarts = probStarts;
        this.probStops = probStops;
        this.answerStarts = answerStarts;
        this.answerStops = answerStops;
    }

    public void findAnswersInProblem(int pid) {
	ArrayList<Integer> startList = new ArrayList<>(),
	    stopList = new ArrayList<>();
	int i = probStarts[pid]; // starting character index for problem pid
	int stop = probStops[pid];
	PatternMatcher patternMatcher = new PatternMatcher(chars);
	for (; i < stop && !patternMatcher.match(i, beginEnumerate); i++) ;
	if (i == stop)
	    throw new RuntimeException
		("No \\begin{enumerate} found for problem "+pid);
	for (; i < stop; i++) {
	    if (patternMatcher.match(i, endEnumerate)) {
		if (!startList.isEmpty()) stopList.add(i);
		break;
	    }
	    if (patternMatcher.match(i, item)) {
		if (!startList.isEmpty()) stopList.add(i);
		startList.add(i);
	    }
	}
	if (i == stop)
	    throw new RuntimeException
		("No \\end{enumerate} found for problem "+pid);
	int nanswer = startList.size();
	assert nanswer == stopList.size();
    ToArray toArray = new ToArray();
	answerStarts[pid] = toArray.toArray(startList);
	answerStops[pid] = toArray.toArray(stopList);
    }
}
